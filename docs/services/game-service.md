# Игровой сервис (Game Service)

Игровой сервис является основным компонентом бэкенда Bomberman Online, отвечающим за всю логику игровой сессии: управление состоянием игры, обработку действий игроков, симуляцию игрового мира, взаимодействие с картами и командами, а также коммуникацию с другими сервисами через NATS.

## Назначение сервиса

`Game Service` симулирует динамическое окружение для каждой игровой сессии. Он принимает входные данные от игроков, обновляет игровое состояние (позиции сущностей, взрывы, сбор бонусов), управляет игровыми режимами (кампания, каждый сам за себя, захват флага) и обеспечивает постоянную синхронизацию состояния игры с клиентами через NATS. Он также предоставляет HTTP API для управления играми, картами и командами.

## Используемые технологии

*   **Python 3.12**: Основной язык программирования.
*   **FastAPI**: Высокопроизводительный веб-фреймворк для построения API.
*   **Uvicorn**: ASGI-сервер для запуска FastAPI-приложения.
*   **SQLAlchemy (`sqlalchemy[asyncio]`, `asyncpg`)**: ORM для взаимодействия с PostgreSQL, включая асинхронные операции.
*   **Alembic**: Инструмент для миграций базы данных PostgreSQL.
*   **Redis (`redis[hiredis]`)**: Используется для кэширования и временного хранения данных.
*   **NATS (`nats-py`)**: Легковесная, высокопроизводительная система обмена сообщениями для асинхронного взаимодействия между микросервисами (публикация обновлений игры, подписка на действия игроков).
*   **Pydantic (`pydantic`, `pydantic-settings`)**: Для валидации данных, сериализации/десериализации моделей и управления настройками конфигурации.
*   **Python JOSE (`python-jose[cryptography]`)**: Для работы с JSON Web Tokens (JWT) и криптографией.
*   **Passlib (`passlib[bcrypt]`)**: Для хеширования паролей.
*   **Aioprometheus, Prometheus FastAPI Instrumentator, Starlette Exporter**: Для экспорта метрик Prometheus из FastAPI-приложения.
*   **NumPy (`numpy`)**: Для эффективной работы с матрицами (например, для сетки карты).
*   **Quantile-Python**: Вероятно, используется для каких-то статистических расчетов или работы с квантилями.
*   **Python JSON Logger (`python-json-logger`)**: Для структурированного логирования.
*   **Typer**: Для создания командной строки (вероятно, для Alembic или других утилит).
*   **Consul (`py-consul`)**: Для регистрации сервиса и проверки его работоспособности.
*   **UV**: Менеджер пакетов Python.

## Структура проекта

```
services/game-service/
├── alembic.ini               # Конфигурация Alembic
├── app/
│   ├── __init__.py
│   ├── alembic/              # Скрипты миграций Alembic
│   │   ├── versions/
│   │   └── ...
│   ├── auth.py               # Логика аутентификации/авторизации (проверка заголовков от Traefik)
│   ├── config.py             # Конфигурационные настройки сервиса
│   ├── coordinators/         # Координаторы высокоуровневой логики
│   │   └── game_coordinator.py # Управление игровыми сессиями и игровым циклом
│   ├── dependenties.py       # Инъекция зависимостей
│   ├── entities/             # Определение игровых сущностей (игроки, враги, бомбы, карты и т.д.)
│   │   ├── bomberman.py
│   │   ├── cell_type.py
│   │   ├── enemy.py
│   │   ├── game_mode.py
│   │   ├── game_status.py
│   │   ├── map.py
│   │   ├── player.py
│   │   ├── power_up.py
│   │   ├── weapon.py
│   │   └── ...
│   ├── logging_config.py     # Конфигурация логирования
│   ├── main.py               # Основное приложение FastAPI и точка входа
│   ├── manage.py             # Скрипты управления (например, для Alembic)
│   ├── models/               # Pydantic модели для данных (игры, карты, команды) и SQLAlchemy ORM
│   │   ├── game_models.py
│   │   ├── map_models.py
│   │   ├── team_models.py
│   │   └── ...
│   ├── repositories/         # Взаимодействие с базами данных и NATS
│   │   ├── map_repository.py
│   │   ├── nats_repository.py
│   │   ├── postgres_repository.py
│   │   └── redis_repository.py
│   ├── routes/               # API-эндпоинты (FastAPI Routers)
│   │   ├── api_v1/
│   │   │   └── ... # Возможно, старые роуты
│   │   ├── entity_routes.py  # Эндпоинты для получения информации о сущностях
│   │   ├── game_routes.py    # Эндпоинты для управления играми (создание, получение, обновление статуса, добавление игроков)
│   │   ├── map_routes.py     # Эндпоинты для управления шаблонами, группами и цепочками карт
│   │   └── team_routes.py    # Эндпоинты для управления командами
│   └── services/             # Бизнес-логика сервисов
│       ├── event_service.py    # Отправка и подписка на NATS-события
│       ├── game_mode_service.py # Базовый класс для игровых режимов
│       ├── game_service.py     # Основная логика игровой сессии
│       ├── map_service.py      # Генерация и загрузка карт
│       ├── team_service.py     # Управление командами
│       └── modes/              # Специфические реализации игровых режимов
│           ├── campaign_mode.py
│           ├── capture_flag_mode.py
│           └── free_for_all_mode.py
├── Dockerfile                # Определение Docker образа для сервиса
├── docs/                     # Дополнительная документация (архитектура, NATS события и т.д.)
│   ├── api_endpoints.md
│   ├── architecture/
│   ├── diagrams/
│   └── ...
├── maps/                     # Место для хранения файлов карт
├── pyproject.toml            # Управление зависимостями проекта (uv)
├── README.md                 # Общие сведения о сервисе
└── uv.lock                   # Файл блокировки зависимостей uv
```

## API-эндпоинты

Все API-эндпоинты имеют префикс `/games/api/v1`.

### Эндпоинты игр (`/games`)

*   `GET /games/`: Получить список игр с фильтрацией.
    *   **Параметры запроса (Query Parameters)**:
        *   `status` (Optional[GameStatus]): Фильтр по статусу игры (`PENDING`, `ACTIVE`, `PAUSED`, `FINISHED`).
        *   `game_mode` (Optional[GameModeType]): Фильтр по игровому режиму (`CAMPAIGN`, `FREE_FOR_ALL`, `CAPTURE_THE_FLAG`).
        *   `has_free_slots` (Optional[bool]): Фильтр по наличию свободных слотов.
        *   `min_players` (Optional[int]): Минимальное количество игроков.
        *   `max_players` (Optional[int]): Максимальное количество игроков.
        *   `limit` (int): Количество записей на страницу (по умолчанию 20).
        *   `offset` (int): Смещение для пагинации (по умолчанию 0).
    *   **Ответ**: `List[GameListItem]`
*   `GET /games/{game_id}`: Получить подробную информацию об игре по ID.
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
    *   **Ответ**: `GameInfo`
*   `PUT /games/{game_id}/settings`: Обновить настройки игры (только для игр в статусе `PENDING`).
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
    *   **Тело запроса (Request Body)**: `GameSettingsUpdate` (JSON).
    *   **Ответ**: `StandardResponse`
*   `PUT /games/{game_id}/status`: Изменить статус игры (`start`/`pause`/`resume`).
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
    *   **Тело запроса (Request Body)**: `GameStatusUpdate` (JSON).
    *   **Ответ**: `StandardResponse`
*   `POST /games/{game_id}/players`: Добавить игрока в игру.
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
    *   **Тело запроса (Request Body)**: `PlayerAction` (JSON).
    *   **Ответ**: `StandardResponse`
*   `DELETE /games/{game_id}/players/{player_id}`: Удалить игрока из игры.
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
        *   `player_id` (str): Уникальный идентификатор игрока.
    *   **Ответ**: `StandardResponse`
*   `DELETE /games/{game_id}`: Удалить игру (мягкое удаление).
    *   **Параметры пути (Path Parameters)**:
        *   `game_id` (str): Уникальный идентификатор игры.
    *   **Ответ**: `StandardResponse`

### Эндпоинты сущностей (`/entities`)

*   `GET /entities/info`: Получить информацию о доступных игровых сущностях и их типах (CellType, GameModeType, GameStatus, EnemyType, PowerUpType, Player units, Weapon types) с их размерами.
    *   **Ответ**: `Dict[str, Any]`

### Эндпоинты карт (`/maps`)

*   `POST /maps/templates`: Создать новый шаблон карты.
    *   **Тело запроса**: `MapTemplateCreate` (JSON).
    *   **Ответ**: `MapTemplate` (статус 201).
*   `GET /maps/templates`: Получить список шаблонов карт с фильтрацией.
    *   **Параметры запроса**: `name`, `difficulty_min`, `difficulty_max`, `max_players_min`, `max_players_max`, `created_by`, `limit`, `offset`.
    *   **Ответ**: `List[MapTemplate]`.
*   `GET /maps/templates/{template_id}`: Получить шаблон карты по ID.
    *   **Параметры пути**: `template_id`.
    *   **Ответ**: `MapTemplate`.
*   `PUT /maps/templates/{template_id}`: Обновить шаблон карты.
    *   **Параметры пути**: `template_id`.
    *   **Тело запроса**: `MapTemplateUpdate`.
    *   **Ответ**: `MapTemplate`.
*   `DELETE /maps/templates/{template_id}`: Удалить шаблон карты (мягкое удаление).
    *   **Параметры пути**: `template_id`.
    *   **Ответ**: Статус 204.
*   `POST /maps/groups`: Создать новую группу карт.
    *   **Тело запроса**: `MapGroupCreate`.
    *   **Ответ**: `MapGroup` (статус 201).
*   `GET /maps/groups`: Получить список групп карт.
    *   **Параметры запроса**: `name`, `created_by`, `limit`, `offset`.
    *   **Ответ**: `List[MapGroup]`.
*   `GET /maps/groups/{group_id}`: Получить группу карт по ID.
    *   **Параметры пути**: `group_id`.
    *   **Ответ**: `MapGroup`.
*   `PUT /maps/groups/{group_id}`: Обновить группу карт.
    *   **Параметры пути**: `group_id`.
    *   **Тело запроса**: `MapGroupUpdate`.
    *   **Ответ**: `MapGroup`.
*   `DELETE /maps/groups/{group_id}`: Удалить группу карт (мягкое удаление).
    *   **Параметры пути**: `group_id`.
    *   **Ответ**: Статус 204.
*   `POST /maps/chains`: Создать новую цепочку карт.
    *   **Тело запроса**: `MapChainCreate`.
    *   **Ответ**: `MapChain` (статус 201).
*   `GET /maps/chains`: Получить список цепочек карт.
    *   **Параметры запроса**: `name`, `created_by`, `limit`, `offset`.
    *   **Ответ**: `List[MapChain]`.
*   `GET /maps/chains/{chain_id}`: Получить цепочку карт по ID.
    *   **Параметры пути**: `chain_id`.
    *   **Ответ**: `MapChain`.
*   `PUT /maps/chains/{chain_id}`: Обновить цепочку карт.
    *   **Параметры пути**: `chain_id`.
    *   **Тело запроса**: `MapChainUpdate`.
    *   **Ответ**: `MapChain`.
*   `DELETE /maps/chains/{chain_id}`: Удалить цепочку карт (мягкое удаление).
    *   **Параметры пути**: `chain_id`.
    *   **Ответ**: Статус 204.

### Эндпоинты команд (`/teams`)

*   `GET /teams/{game_id}`: Получить список команд для игры.
    *   **Параметры пути**: `game_id`.
    *   **Ответ**: `List[Team]`.
*   `POST /teams/{game_id}`: Создать новую команду в игре.
    *   **Параметры пути**: `game_id`.
    *   **Тело запроса**: `TeamCreate`.
    *   **Ответ**: `Team` (статус 201).
*   `PUT /teams/{game_id}/{team_id}`: Обновить команду.
    *   **Параметры пути**: `game_id`, `team_id`.
    *   **Тело запроса**: `TeamUpdate`.
    *   **Ответ**: `Team`.
*   `DELETE /teams/{game_id}/{team_id}`: Удалить команду.
    *   **Параметры пути**: `game_id`, `team_id`.
    *   **Ответ**: Статус 204.
*   `POST /teams/{game_id}/{team_id}/players`: Добавить игрока в команду.
    *   **Параметры пути**: `game_id`, `team_id`.
    *   **Тело запроса**: `PlayerTeamAction`.
    *   **Ответ**: `Team`.
*   `DELETE /teams/{game_id}/{team_id}/players/{player_id}`: Удалить игрока из команды.
    *   **Параметры пути**: `game_id`, `team_id`, `player_id`.
    *   **Ответ**: `Team`.
*   `POST /teams/{game_id}/distribute`: Автоматически распределить игроков по командам.
    *   **Параметры пути**: `game_id`.
    *   **Тело запроса**: `TeamDistributionRequest`.
    *   **Ответ**: `List[Team]`.
*   `GET /teams/{game_id}/validate`: Проверить корректность настройки команд.
    *   **Параметры пути**: `game_id`.
    *   **Ответ**: `Dict` с ошибками валидации.

### Эндпоинт здоровья (`/health`)

*   `GET /health`: Проверка статуса сервиса.
    *   **Ответ**: `Dict` с информацией о статусе.

## Переменные окружения

Конфигурация сервиса осуществляется через следующие переменные окружения. Значения по умолчанию указаны, если не заданы в файле `.env` или окружении.

| Переменная                     | Описание                                                                  | Значение по умолчанию (`app/config.py`) |
| :----------------------------- | :------------------------------------------------------------------------ | :------------------------------------- |
| `SERVICE_NAME`                 | Имя сервиса, по умолчанию.                                                | `game-service`                         |
| `API_V1_STR`                   | Префикс URL для всех API эндпоинтов V1.                                   | `/games/api/v1`                        |
| `APP_TITLE`                    | Заголовок приложения (для Swagger).
| `HOST`                         | Хост, на котором запускается FastAPI приложение.                          | `0.0.0.0`                              |
| `PORT`                         | Порт, на котором запускается FastAPI приложение.                          | `5002`                                 |
| `DEBUG`                        | Включает режим отладки FastAPI.                                           | `True`                                 |
| `RELOAD`                       | Включает автоматическую перезагрузку Uvicorn при изменениях кода.         | `True`                                 |
| `SWAGGER_URL`                  | URL для доступа к Swagger UI документации.                                | `/games/docs`                          |
| `CONSUL_HOST`                  | Хост Consul для обнаружения сервисов.                                     | `localhost`                            |
| `HOSTNAME`                     | Хостнейм текущего сервиса.                                                | `localhost`                            |
| `WEBAPI_SERVICE_HOSTNAME`      | Хостнейм сервиса WebAPI для взаимодействия.                               | `localhost`                            |
| `CORS_ORIGINS`                 | Список разрешенных источников для CORS (через запятую или JSON список).   | `["*"]` (все источники)              |
| `CORS_CREDENTIALS`             | Разрешает ли CORS передачу credentials (например, cookie).                | `True`                                 |
| `CORS_METHODS`                 | Список разрешенных HTTP методов для CORS.                                 | `["*"]` (все методы)                 |
| `CORS_HEADERS`                 | Список разрешенных HTTP заголовков для CORS.                              | `["*"]` (все заголовки)              |
| `POSTGRES_HOST`                | Хост для подключения к базе данных PostgreSQL.                            | `localhost`                            |
| `POSTGRES_PORT`                | Порт для подключения к PostgreSQL.                                        | `5432`                                 |
| `POSTGRES_DB`                  | Имя базы данных PostgreSQL для игрового сервиса.                          | `game_service`                         |
| `POSTGRES_USER`                | Имя пользователя для подключения к PostgreSQL.                            | `bomberman`                            |
| `POSTGRES_PASSWORD`            | Пароль пользователя для подключения к PostgreSQL.                         | `bomberman`                            |
| `REDIS_HOST`                   | Хост для подключения к Redis.                                             | `localhost`                            |
| `REDIS_PORT`                   | Порт для подключения к Redis.                                             | `6379`                                 |
| `REDIS_DB`                     | Номер базы данных Redis.                                                  | `0`                                    |
| `REDIS_PASSWORD`               | Пароль для подключения к Redis (если требуется).                          | `None`                                 |
| `NATS_URL`                     | URL NATS сервера.                                                         | `nats://localhost:4222`                |
| `LOG_LEVEL`                    | Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL).              | `INFO`                                 |
| `LOG_FORMAT`                   | Формат логов (`text` или `json`).                                         | `text`                                 |
| `TRACE_CALLER`                 | Включает ли добавление информации о вызывающих функциях в JSON логи.      | `True`                                 |
| `GAME_UPDATE_FPS`              | Частота обновления игрового состояния в секундах (кадры в секунду).      | `30.0`                                 |
| `GAME_OVER_TIMEOUT`            | Время ожидания перед завершением игровой сессии после окончания игры.    | `5.0` (секунды)                        |

## NATS-события

Game Service активно использует NATS для асинхронного обмена сообщениями. Он как подписывается на события для выполнения действий, так и публикует обновления игрового состояния.

### Подписка на события

Сервис подписывается на следующие события (обрабатываются `GameCoordinator` через `EventService`):

*   `game.create`: Запрос на создание новой игры. Ожидаемый payload включает `game_id` и `new_game_settings`.
*   `game.join`: Запрос на присоединение игрока к игре. Ожидаемый payload включает `game_id` и `player_id`.
*   `game.input`: Ввод игрока (движения, действия). Ожидаемый payload включает `game_id`, `player_id` и `inputs`.
*   `game.place_weapon`: Запрос на размещение оружия игроком. Ожидаемый payload включает `game_id`, `player_id` и `weapon_action`.
*   `game.get_state`: Запрос на получение текущего состояния игры. Ожидаемый payload включает `game_id`.
*   `game.disconnect`: Уведомление об отключении игрока от игры. Ожидаемый payload включает `game_id` и `player_id`.

### Публикация событий

Сервис публикует следующие события:

*   `game.state_update`: Обновление текущего состояния игры. Отправляется регулярно для синхронизации клиентов.
    *   **Payload (JSON)**: Полное или частичное состояние игры.
*   `game.player_action_response`: Ответ на действие игрока (успех/неудача).
    *   **Payload (JSON)**: `{"success": true, "message": "..."}`
*   `game.instance_allocated`: Подтверждение распределения игры на конкретный игровой сервер.
    *   **Payload (JSON)**: `{"game_id": "...", "instance_id": "..."}`

## Взаимодействие с другими сервисами

*   **Auth Service**: Игровой сервис не взаимодействует напрямую с `Auth Service`. Авторизация пользователей осуществляется на уровне Traefik, который добавляет информацию о пользователе (`X-User-ID`, `X-User-Role` и т.д.) в заголовки запросов, прежде чем они достигают `Game Service`.
*   **Game Allocator Service**: `Game Service` не инициирует прямое взаимодействие. `Game Allocator Service` выбирает подходящий `Game Service` для новой игры и отправляет ему NATS-событие `game.create`.
*   **PostgreSQL**: Используется для постоянного хранения данных о картах (шаблоны, группы, цепочки) и, возможно, других метаданных игры (хотя основные игровые данные хранятся в памяти на время сессии).
*   **Redis**: Используется для кэширования игровых состояний или других временных данных. Также может использоваться для управления блокировками или распределенными мьютексами, если это потребуется для масштабирования.
*   **NATS**: Основной канал асинхронного взаимодействия с другими сервисами (например, `WebAPI Service` для получения действий игроков и отправки обновлений).
*   **Prometheus**: Экспортирует метрики для мониторинга производительности и состояния `Game Service`.
*   **Consul**: Используется для регистрации `Game Service` в качестве доступного экземпляра, позволяя `Game Allocator Service` обнаруживать его и проверять работоспособность.

## Внутренняя архитектура

### Координаторы

*   **`game_coordinator.py`**: Управляет жизненным циклом игровых сессий. Отвечает за создание, обновление и завершение игр, а также за обработку входящих NATS-событий, связанных с играми (например, создание игры, присоединение игрока, ввод данных игрока). Включает основной игровой цикл, который периодически обновляет состояние всех активных игр и отправляет обновления через NATS.

### Сущности (`app/entities`)

Директория `entities` содержит определения всех игровых сущностей. Каждая сущность является объектом, представляющим элемент игрового мира, обладающий своим состоянием, поведением и возможностями взаимодействия.

*   **`entity.py`**: Базовый класс `Entity` для всех игровых сущностей. Определяет общие свойства (позиция, размер, ID, имя, состояние разрушения, скорость, жизни, неуязвимость, цвет) и базовое поведение (движение, проверка коллизий, обновление состояния, получение изменений). Все остальные сущности наследуются от этого класса.
*   **`bomberman.py`**: Определяет сущность игрока-бомбермена. Включает специфические для игрока атрибуты, такие как бонусы (радиус бомбы, количество бомб, сила взрыва, скорость), а также логику обработки ввода игрока и размещения бомб.
*   **`bullet.py`**: Определяет сущность пули, выпущенной оружием. Содержит логику движения пули, ее столкновений с другими сущностями и нанесения урона.
*   **`cell_type.py`**: Определяет перечисление (`Enum`) типов клеток карты (например, стена, разрушаемая стена, пол, выход), используемых для построения игрового поля.
*   **`enemy.py`**: Определяет сущность врага. Включает базовое поведение ИИ для движения и взаимодействия с игровым миром.
*   **`game_mode.py`**: Определяет базовый класс для игровых режимов, а также перечисление (`Enum`) `GameModeType` для различных режимов (кампания, каждый сам за себя, захват флага).
*   **`game_status.py`**: Определяет перечисление (`Enum`) `GameStatus` для различных состояний игры (ожидание, активна, на паузе, завершена).
*   **`inputs.py`**: Определяет классы или структуры для обработки входных данных от игроков (движения, действия).
*   **`map.py`**: Определяет сущность карты игрового мира. Включает логику загрузки, генерации и управления игровым полем, включая размещение сущностей, обработку разрушаемых блоков и навигацию.
*   **`mine.py`**: Определяет сущность мины, устанавливаемой игроком. Включает логику активации, взрыва и нанесения урона.
*   **`player.py`**: Определяет базовую сущность игрока. Содержит информацию о подключении, статистике игрока и инвентаре бонусов.
*   **`power_up.py`**: Определяет сущности бонусов (например, увеличение радиуса бомбы, дополнительная бомба, увеличение скорости), которые игроки могут собирать в игре.
*   **`tank.py`**: Определяет сущность танка, другого типа управляемой единицы или врага.
*   **`team.py`**: Определяет сущность команды, используемую в командных игровых режимах, и содержит логику управления игроками в команде.
*   **`weapon.py`**: Определяет базовые классы и перечисления (`Enum`) для различных типов оружия и действий с ним (например, бомбы, пушки, мины).

### Зависимости (`app/dependenties.py`)

*   **`dependenties.py`**: Модуль, содержащий инъекции зависимостей FastAPI для API-эндпоинтов, таких как получение текущей сессии базы данных и аутентификация пользователя (проверка заголовков от Traefik).

## Инструкции по запуску и развертыванию

### Локальный запуск (с Docker Compose)

1.  **Убедитесь, что Docker и Docker Compose установлены.**
2.  **Запустите все необходимые инфраструктурные сервисы через Docker Compose**: Перейдите в корневую директорию проекта (`BombermanOnline`) и выполните:
    ```bash
    docker-compose -f infra/docker-compose.yml up -d
    ```
    Это запустит PostgreSQL, Redis, NATS, Consul, Prometheus и другие сервисы, от которых зависит `game-service`.
3.  **Выполните миграции базы данных**: Перейдите в директорию `services/game-service` и выполните:
    ```bash
    alembic upgrade head
    ```
    Убедитесь, что база данных PostgreSQL доступна.
4.  **Соберите и запустите `game-service`**: Перейдите в директорию сервиса:
    ```bash
    cd services/game-service
    ```
    Затем соберите Docker образ и запустите контейнер:
    ```bash
    docker build -t game-service .
    docker run --network bombermanonline_default -p 5002:5002 game-service
    ```
    *(Примечание: Сеть `bombermanonline_default` создается при запуске `infra/docker-compose.yml`)*

### Запуск в режиме разработки (без Docker)

1.  **Установите Python 3.12 и UV.**
2.  **Установите зависимости**: Перейдите в директорию `services/game-service` и выполните:
    ```bash
    uv sync
    ```
3.  **Выполните миграции базы данных**: Убедитесь, что PostgreSQL запущен и доступен, затем выполните:
    ```bash
    alembic upgrade head
    ```
4.  **Запустите сервис**: Убедитесь, что все необходимые внешние сервисы (PostgreSQL, Redis, NATS, Consul) запущены и доступны с вашего хоста. Затем запустите:
    ```bash
    uv run app/main.py
    ```

### Развертывание

Сервис предназначен для развертывания в контейнерной среде (например, Docker, Kubernetes). `Dockerfile` предоставляет все необходимое для создания переносимого образа. Важно убедиться, что переменные окружения настроены правильно для производственной среды, особенно `POSTGRES_HOST`, `REDIS_HOST`, `NATS_URL`, `CONSUL_HOST`, `HOSTNAME`. 

### Бизнес-логика сервисов

*   `event_service.py`: Отправка и подписка на NATS-события, обработка входящих событий и публикация исходящих. Управляет взаимодействием с другими микросервисами через NATS.
*   `game_mode_service.py`: Базовый класс для всех игровых режимов, предоставляющий общую логику для инициализации, управления игроками, обработки столкновений и завершения игры.
*   `game_service.py`: Основная логика управления игровой сессией, включая создание, запуск, паузу, возобновление и завершение игр. Обрабатывает игровой цикл, обновления состояния и взаимодействие сущностей.
*   `map_service.py`: Управление генерацией, загрузкой и валидацией игровых карт. Отвечает за предоставление карт в различных форматах для игровых режимов.
*   `team_service.py`: Управление командами и игроками в командных режимах игры. Обрабатывает добавление/удаление игроков в команды, начисление очков и проверку условий победы для команд.

#### Игровые режимы

*   **Campaign Mode (`campaign_mode.py`)**:
    *   **Описание**: Режим прохождения, ориентированный на кооперативную игру. Игроки работают вместе, чтобы победить врагов и пройти уровни. Игра завершается, когда все игроки мертвы или все враги на уровне убиты.
    *   **Особенности**:
        *   Кооперативное прохождение.
        *   Наличие врагов (если `enable_enemies` включено).
        *   Переход на следующий уровень после уничтожения всех врагов.
        *   Начисление очков команде за завершение уровня.
        *   Сброс карты и позиций игроков при переходе на новый уровень.
    *   **Логика завершения игры**: Все игроки мертвы (поражение) или все враги на текущем уровне уничтожены (переход на следующий уровень).

*   **Capture Flag Mode (`capture_flag_mode.py`)**:
    *   **Описание**: Режим захвата флага, командная игра. Цель каждой команды — захватить флаг противника.
    *   **Особенности**:
        *   Командная игра.
        *   Враги отключены (`enable_enemies = False`).
        *   Отслеживание позиций флагов для каждой команды.
        *   Отслеживание захваченных флагов.
        *   Поддержка респавна игроков (TODO).
    *   **Логика завершения игры**: Одна из команд достигает установленного лимита очков (`score_limit`) или истекает время.

*   **Free For All Mode (`free_for_all_mode.py`)**:
    *   **Описание**: Режим "каждый сам за себя", где игроки сражаются друг с другом индивидуально. Цель — остаться последним выжившим.
    *   **Особенности**:
        *   Индивидуальная игра.
        *   Враги отключены (`enable_enemies = False`).
        *   Убитые игроки исключаются из игры.
    *   **Логика завершения игры**: Остается один живой игрок или истекает время. Победивший игрок получает очки. 