# Игровые Сущности (Entities)

В этом разделе описываются основные игровые сущности, используемые в `game-service`. Эти классы представляют все активные и пассивные элементы игрового мира, их состояние и поведение. 

## 1. Базовая Сущность (`Entity`)

Файл: `app/entities/entity.py`

Класс `Entity` является базовым для всех игровых объектов в сервисе. Он определяет общие атрибуты и методы, которые могут быть унаследованы и/или переопределены дочерними классами.

- **Основные атрибуты:**
    - `x` (float): Координата X на карте.
    - `y` (float): Координата Y на карте.
    - `width` (float): Ширина сущности.
    - `height` (float): Высота сущности.
    - `id` (str): Уникальный идентификатор сущности (генерируется UUID, если не предоставлен).
    - `name` (str): Имя сущности (например, "Player 1", "SimpleEnemy").
    - `ai` (bool): Флаг, указывающий, управляется ли сущность искусственным интеллектом.
    - `speed` (float): Скорость передвижения сущности.
    - `lives` (int): Количество жизней.
    - `invulnerable` (bool): Флаг неуязвимости.
    - `invulnerable_timer` (float): Таймер неуязвимости в секундах.
    - `color` (str): Цвет сущности в HEX формате (например, "#FFFFFF").

- **Основные методы:**
    - `__init__(...)`: Конструктор класса, инициализирует атрибуты сущности.
    - `update(delta_time: float) -> None`: Обновляет состояние сущности. В базовом классе реализует логику таймера неуязвимости. Этот метод предназначен для расширения в дочерних классах для специфической логики обновления (например, движение, атака).
    - `draw() -> dict`: Возвращает словарь с данными, необходимыми для отрисовки сущности на клиенте. Включает `id`, `x`, `y`, `width`, `height`, `color`, `name`, `lives`, `invulnerable`. 

## 2. Перечисления Типов

### 2.1. Типы Юнитов (`UnitType`)

Файл: `app/entities/unit_type.py`

Перечисление `UnitType` определяет возможные типы игровых юнитов (обычно игроков или управляемых AI персонажей).

- **Значения:**
    - `BOMBERMAN`: Классический тип юнита "Бомбермен".
    - `TANK`: Тип юнита "Танк", который может использовать пули.

### 2.2. Типы Клеток Карты (`CellType`)

Файл: `app/entities/cell_type.py`

Перечисление `CellType` (наследуемое от `IntEnum`) определяет различные типы клеток, из которых состоит игровая карта. Эти типы используются в `Map.grid_data` для представления структуры уровня.

- **Значения:**
    - `EMPTY` (0): Пустая клетка, по которой можно свободно перемещаться.
    - `SOLID_WALL` (1): Сплошная (неразрушаемая) стена.
    - `BREAKABLE_BLOCK` (2): Разрушаемый блок, который может быть уничтожен взрывом и может содержать усиление.
    - `PLAYER_SPAWN` (3): Точка появления игрока.
    - `ENEMY_SPAWN` (4): Точка появления врага.
    - `LEVEL_EXIT` (5): Выход с уровня (актуально для режима Кампании).

### 2.3. Типы Игровых Режимов (`GameModeType`)

Файл: `app/entities/game_mode.py`

Перечисление `GameModeType` определяет доступные игровые режимы в сервисе.

- **Значения:**
    - `CAMPAIGN` ("campaign"): Режим прохождения кампании, возможно кооперативное.
    - `FREE_FOR_ALL` ("free_for_all"): Режим "каждый сам за себя", где количество игроков равно количеству команд.
    - `CAPTURE_THE_FLAG` ("capture_the_flag"): Командный режим с захватом флагов.

### 2.4. Статусы Игры (`GameStatus`)

Файл: `app/entities/game_status.py`

Перечисление `GameStatus` определяет возможные состояния игровой сессии.

- **Значения:**
    - `PENDING` ("pending"): Ожидание игроков - игра создана, но еще не запущена.
    - `STARTING` ("starting"): Подготовка к запуску игры.
    - `ACTIVE` ("active"): Активная игра - основной игровой процесс.
    - `PAUSED` ("paused"): Игра приостановлена.
    - `FINISHED` ("finished"): Игра завершена.

## 3. Система Команд

### 3.1. Команда (`Team`)

Файл: `app/entities/team.py`

Класс `Team` представляет команду в игре - группу игроков, объединенных общими целями и системой подсчета очков.

- **Основные атрибуты:**
    - `id` (str): Уникальный идентификатор команды (генерируется UUID, если не предоставлен).
    - `name` (str): Название команды (генерируется автоматически, если не предоставлено).
    - `score` (int): Очки команды.
    - `player_ids` (List[str]): Список идентификаторов игроков в команде.

- **Основные методы:**
    - `__init__(team_id: str = None, name: str = None)`: Инициализирует команду с указанным ID и названием.
    - `add_player(player_id: str) -> None`: Добавляет игрока в команду, если он еще не состоит в ней.
    - `remove_player(player_id: str) -> bool`: Удаляет игрока из команды. Возвращает True, если игрок был удален.
    - `add_score(points: int) -> None`: Добавляет очки к счету команды.
    - `get_player_count() -> int`: Возвращает количество игроков в команде.
    - `to_dict() -> dict`: Возвращает словарь с данными команды для API и сериализации.

### 3.2. Настройки Команд для Режимов (`TeamModeSettings`)

Файл: `app/entities/team_settings.py`

Класс `TeamModeSettings` (Pydantic `BaseModel`) определяет правила формирования и управления командами для конкретного игрового режима.

- **Основные атрибуты:**
    - `default_team_count` (int): Количество команд по умолчанию для режима.
    - `max_team_count` (int): Максимально допустимое количество команд.
    - `min_players_per_team` (int): Минимальное количество игроков в команде.
    - `max_players_per_team` (int): Максимальное количество игроков в команде.
    - `auto_distribute_players` (bool): Автоматически распределять игроков по командам.
    - `allow_uneven_teams` (bool): Разрешить неравные по размеру команды.
    - `default_team_names` (List[str]): Список названий команд по умолчанию.

- **Настройки для разных режимов:**
    - **CAMPAIGN**: 1 команда до 8 игроков с автоматическим распределением.
    - **FREE_FOR_ALL**: Индивидуальные команды по 1 игроку каждая.
    - **CAPTURE_THE_FLAG**: 2-4 команды с балансированным распределением игроков.

Константа `TEAM_MODE_SETTINGS` содержит предустановленные настройки для каждого игрового режима.

## 4. Настройки Игры (`GameSettings`)

Файл: `app/entities/game_settings.py`

Класс `GameSettings` (Pydantic `BaseModel`) агрегирует все параметры, определяющие правила и характеристики текущей игровой сессии. Экземпляр этого класса создается для каждой игры и используется различными компонентами сервиса (например, `GameModeService`, `MapService`) для корректной работы игровой логики.

- **Назначение:**
    - Определяет физические параметры мира (размер клетки, размеры карты по умолчанию).
    - Задает характеристики игроков (скорость, время неуязвимости, начальное количество жизней).
    - Конфигурирует параметры оружия (таймеры и мощность бомб, скорость пуль, таймер мин).
    - Управляет поведением и количеством врагов.
    - Определяет систему начисления очков.
    - Задает вероятности появления усилений.
    - Содержит параметры для генерации случайных карт.
    - Хранит специфичные для сессии настройки, такие как `game_id`, `game_mode`, `max_players`, `team_count`, используемые карты (`map_chain_id`, `map_template_id`), и правила вроде `respawn_enabled`, `friendly_fire`, `time_limit`, `score_limit`, `rounds_count`.

- **Использование:**
    - Часть настроек имеет значения по умолчанию, заданные в классе.
    - Другая часть настроек может быть переопределена при создании игры через модель `GameCreateSettings` (см. раздел [Модели Данных](./models.md#23-модели-для-создания-игры) и [Конфигурация](../configuration.md#22-параметры-настраиваемые-при-создании-игры)).
    - Экземпляр `GameSettings` передается в конструкторы `GameService` и `GameModeService`, делая настройки доступными для всей логики конкретной игры.

Подробное описание каждой переменной и ее значения по умолчанию можно найти в разделе [Конфигурация](../configuration.md#2-настройки-игровой-сессии-appentitiesgame_settingspy). 

## 5. Оружие

Система оружия в игре представлена базовым абстрактным классом `Weapon` и его конкретными реализациями, а также перечислением `WeaponType`.

### 5.1. Типы Оружия (`WeaponType`)

Файл: `app/entities/weapon.py`

Перечисление `WeaponType` определяет различные виды оружия, доступные в игре.

- **Значения:**
    - `BOMB` ("bomb"): Классическая бомба.
    - `BULLET` ("bullet"): Пуля, используемая, например, танком.
    - `MINE` ("mine"): Мина.

### 5.2. Базовый Класс Оружия (`Weapon`)

Файл: `app/entities/weapon.py`

`Weapon` — это абстрактный базовый класс (наследуется от `Entity` и `abc.ABC`) для всех видов оружия в игре. Он определяет общие атрибуты и методы, которые должны быть реализованы конкретными классами оружия.

- **Основные атрибуты (в дополнение к унаследованным от `Entity`):**
    - `weapon_type` (`WeaponType`): Тип оружия.
    - `owner_id` (str): Идентификатор сущности (обычно игрока), которая использовала это оружие.
    - `activated` (bool): Флаг, указывающий, активировано ли оружие (например, бомба поставлена и тикает, мина готова взорваться).
    - `timer` (float): Внутренний таймер оружия (например, для отсчета времени до взрыва бомбы).

- **Абстрактные методы (должны быть реализованы в подклассах):**
    - `activate() -> None`: Активирует оружие. Логика зависит от типа оружия (например, для бомбы — начало отсчета таймера, для пули — мгновенное действие).
    - `update(delta_time: float) -> None`: Обновляет состояние оружия. Например, уменьшает таймер, проверяет столкновения (для пули).
    - `get_damage_area() -> list[tuple[int, int]]`: Возвращает список координат клеток (`(x, y)`), которые затрагивает оружие при срабатывании (например, область взрыва бомбы). 

### 5.3. Бомба (`Bomb`)

Файл: `app/entities/bomb.py`

Класс `Bomb` представляет собой классическую бомбу, которую могут устанавливать игроки.

- **Наследование:** `Weapon`
- **Основные атрибуты (в дополнение к унаследованным):**
    - `power` (int): Сила (радиус) взрыва бомбы. Определяет, на сколько клеток распространится взрыв в каждом из четырех направлений.
    - `exploded` (bool): Флаг, указывающий, что бомба уже взорвалась (фаза отображения взрыва).
    - `explosion_timer` (float): Таймер, отсчитывающий длительность отображения взрыва.
    - `explosion_cells` (list[tuple[int, int]]): Список координат клеток, затронутых взрывом. Этот список заполняется в момент взрыва (в логике `GameModeService`).

- **Реализация методов:**
    - `__init__(x, y, size, power, owner_id)`: Инициализирует бомбу с указанной силой и владельцем. Таймер (`self.timer`) изначально 0; он увеличивается в `update` до момента взрыва, который определяется внешней логикой (например, в `GameModeService` на основе `GameSettings.bomb_timer`).
    - `activate() -> None`: Устанавливает `self.activated = True` и `self.exploded = True`. Этот метод вызывается, когда бомба должна взорваться (логика фактического взрыва и расчета `explosion_cells` находится в `GameModeService.handle_bomb_explosion`).
    - `update(delta_time: float) -> None`: Если бомба уже взорвалась (`self.exploded`), увеличивает `self.explosion_timer`. В противном случае, увеличивает `self.timer` (этот таймер используется для отслеживания времени жизни бомбы до взрыва, инициируемого извне).
    - `get_damage_area() -> list[tuple[int, int]]`: Возвращает копию списка `self.explosion_cells`.

- **Логика взрыва:** Важно отметить, что фактический расчет области взрыва (`explosion_cells`) и проверка столкновений с другими объектами происходят не в классе `Bomb` напрямую, а в `GameModeService` (метод `handle_bomb_explosion`). Класс `Bomb` в основном хранит состояние, связанное с таймерами и фактом взрыва, а также предоставляет область поражения после ее расчета. 

### 5.4. Пуля (`Bullet`)

Файл: `app/entities/bullet.py`

Класс `Bullet` представляет собой снаряд (пулю), который может быть выпущен, например, юнитом типа `TANK`.

- **Наследование:** `Weapon`
- **Основные атрибуты (в дополнение к унаследованным):**
    - `direction` (tuple[float, float]): Нормализованный вектор `(dx, dy)`, указывающий направление движения пули.
    - `speed` (float): Скорость полета пули.
    - `hit_target` (bool): Флаг, указывающий, что пуля достигла цели или столкнулась с препятствием.

- **Реализация методов:**
    - `__init__(x, y, size, direction, speed, owner_id)`: Инициализирует пулю с начальной позицией, направлением, скоростью и владельцем.
    - `activate() -> None`: Устанавливает `self.activated = True` и `self.hit_target = True`. Этот метод вызывается, когда пуля попадает в цель или препятствие (логика обнаружения столкновений находится в `GameModeService`).
    - `update(delta_time: float) -> None`: Если пуля еще не поразила цель (`not self.hit_target`), обновляет ее координаты `self.x` и `self.y` на основе направления, скорости и `delta_time`. Также инкрементирует `self.timer` (может использоваться для ограничения дальности полета или времени жизни пули, если такая логика будет добавлена).
    - `get_damage_area() -> list[tuple[int, int]]`: Возвращает список, содержащий одну пару координат `(grid_x, grid_y)`, представляющую текущую ячейку, в которой находится центр пули. Для преобразования абсолютных координат в сеточные используется `GameSettings.cell_size`.

- **Логика движения и столкновений:** Перемещение пули реализовано в ее методе `update`. Обнаружение столкновений пули со стенами, разрушаемыми блоками, игроками или врагами, а также вызов `activate()` при столкновении, осуществляется в `GameModeService` (например, в `update_weapon` или специализированных методах проверки столкновений). 

### 5.5. Мина (`Mine`)

Файл: `app/entities/mine.py`

Класс `Mine` представляет собой мину, которая может быть установлена игроком и взрывается при срабатывании или по таймеру после срабатывания.

- **Наследование:** `Weapon`
- **Основные атрибуты (в дополнение к унаследованным):**
    - `exploded` (bool): Флаг, указывающий, что мина уже взорвалась.
    - `triggered` (bool): Флаг, указывающий, что мина была активирована (например, на нее наступили).

- **Реализация методов:**
    - `__init__(x, y, size, owner_id)`: Инициализирует мину с начальной позицией и владельцем.
    - `activate() -> None`: Устанавливает `self.activated = True` и `self.exploded = True`. Этот метод вызывается, когда мина должна взорваться.
    - `trigger() -> None`: Если мина еще не была триггерирована, устанавливает `self.triggered = True`. Этот метод вызывается внешней логикой (в `GameModeService`), когда, например, юнит наступает на клетку с миной.
    - `update(delta_time: float) -> None`: Увеличивает `self.timer`. Если мина была триггерирована (`self.triggered`), не взорвана (`not self.exploded`) и `self.timer` достиг определенного значения (в коде жестко задано `1.0` секунда), то вызывает `self.activate()` для взрыва мины.
    - `get_damage_area() -> list[tuple[int, int]]`: Если мина взорвалась, возвращает список координат клеток, составляющих область поражения 3x3 вокруг центра мины. В противном случае возвращает пустой список. Для преобразования абсолютных координат в сеточные используется `GameSettings.cell_size`.

- **Логика срабатывания и взрыва:**
    - Мина устанавливается на карту.
    - Когда игрок или враг наступает на клетку с миной, `GameModeService` вызывает метод `mine.trigger()`.
    - После триггера, внутренняя логика мины в методе `update()` отсчитывает задержку (1 секунда), после чего мина взрывается (вызывается `activate()`).
    - Область поражения 3x3 клетки. 

## 6. Усиления (Power-Ups)

Система усилений предназначена для предоставления игрокам временных или постоянных преимуществ.

### 6.1. Типы Усилений (`PowerUpType`)

Файл: `app/entities/power_up.py`

Перечисление `PowerUpType` определяет различные виды усилений, которые могут появляться в игре.

- **Значения:**
    - `BOMB_UP`: Увеличивает максимальное количество одновременно размещаемых бомб у игрока.
    - `BOMB_POWER_UP`: Увеличивает силу (радиус) взрыва бомб игрока.
    - `SPEED_UP`: Увеличивает скорость передвижения игрока.
    - `LIFE_UP`: Дает игроку дополнительную жизнь.

### 6.2. Класс Усиления (`PowerUp`)

Файл: `app/entities/power_up.py`

Класс `PowerUp` представляет собой объект усиления, который может быть подобран игроком.

- **Наследование:** `Entity`
- **Основные атрибуты (в дополнение к унаследованным):**
    - `type` (`PowerUpType`): Тип усиления.

- **Реализация методов:**
    - `__init__(x, y, size, power_type)`: Инициализирует усиление с указанным типом и размещает его на карте. Координаты `x`, `y` и `size` относятся к клетке, в которой появляется усиление; фактические размеры самого объекта `PowerUp` могут быть немного меньше для центрирования внутри клетки.
    - `apply_to_player(player: Player) -> None`: Применяет эффект усиления к указанному объекту `player`. В зависимости от `self.type`:
        - `BOMB_UP`: Увеличивает `player.max_bombs` на 1.
        - `BOMB_POWER_UP`: Увеличивает `player.bomb_power` на 1.
        - `SPEED_UP`: Увеличивает `player.speed` на 0.5 (с максимальным ограничением скорости до 6).
        - `LIFE_UP`: Увеличивает `player.lives` на 1.

- **Логика появления и подбора:**
    - Усиления могут появляться на карте после уничтожения разрушаемых блоков или врагов (логика вероятности и спавна находится в `GameModeService`).
    - Когда игрок наступает на клетку с усилением, `GameModeService` обнаруживает это столкновение и вызывает метод `power_up.apply_to_player(player)`, после чего усиление обычно удаляется с карты. 

## 7. Игрок (`Player`)

Файл: `app/entities/player.py`

Класс `Player` представляет игрового персонажа, управляемого пользователем. Он наследуется от `Entity` и добавляет специфическую логику для обработки ввода, управления оружием и командного взаимодействия.

### 7.1. Состояние Ввода Игрока (`Inputs`)

`Inputs` — это `TypedDict`, определяющий структуру для хранения состояния команд ввода от игрока.

- **Поля:**
    - `up` (bool): Нажата ли кнопка движения вверх.
    - `down` (bool): Нажата ли кнопка движения вниз.
    - `left` (bool): Нажата ли кнопка движения влево.
    - `right` (bool): Нажата ли кнопка движения вправо.
    - `weapon1` (bool): Нажата ли кнопка использования основного оружия.
    - `weapon2` (bool): Нажата ли кнопка использования вторичного оружия.

### 7.2. Класс Игрока (`Player`)

- **Наследование:** `Entity`
- **Статические атрибуты:**
    - `COLORS` (list[str]): Список HEX-кодов цветов, используемых для различения игроков (например, `['#3498db', '#e74c3c', ...]`).

- **Основные атрибуты (в дополнение к унаследованным):**
    - `unit_type` (`UnitType`): Тип юнита игрока (например, `UnitType.BOMBERMAN` или `UnitType.TANK`).
    - `team_id` (str): Идентификатор команды, к которой принадлежит игрок.
    - `direction` (tuple[float, float]): Нормализованный вектор `(dx, dy)`, указывающий текущее направление движения/взгляда (особенно актуально для юнита `TANK`, обновляется при получении команд движения).
    - `primary_weapon` (`WeaponType`): Тип основного оружия, зависит от `unit_type` (например, `WeaponType.BOMB` для Бомбермена, `WeaponType.BULLET` для Танка).
    - `secondary_weapon` (`WeaponType`): Тип вторичного оружия (например, `WeaponType.MINE`).
    - `max_weapons` (int): Максимальное количество единиц основного оружия, которое игрок может иметь активным одновременно (например, количество бомб на карте или пуль в "обойме"). Зависит от `unit_type`.
    - `weapon_power` (int): Сила основного оружия (например, радиус взрыва бомбы).
    - `inputs` (`Inputs`): Словарь, хранящий текущее состояние команд ввода от игрока.

- **Свойства (для совместимости и удобства):**
    - `@property max_bombs (int)`: Возвращает `self.max_weapons`, если основное оружие — бомба, иначе 0. Сеттер также обновляет `self.max_weapons`.
    - `@property bomb_power (int)`: Возвращает `self.weapon_power`. Сеттер обновляет `self.weapon_power`.

- **Основные методы:**
    - `__init__(player_id: str, unit_type: UnitType = UnitType.BOMBERMAN)`: Инициализирует игрока с заданным ID и типом юнита. Устанавливает начальные значения для скорости, жизней, цвета, оружия.
    - `set_inputs(inputs: dict) -> None`: Обновляет словарь `self.inputs` на основе полученных данных. Если тип юнита — `TANK`, также обновляет атрибут `self.direction` в соответствии с нажатыми кнопками движения.
    - `set_team(team_id: str) -> None`: Присваивает игроку идентификатор команды `team_id`.
    - `update(delta_time: float) -> None`: (Не реализован в `Player`, но унаследован от `Entity`) Базовый `Entity.update` обрабатывает неуязвимость. Специфическое движение игрока на основе `self.inputs` и столкновения обрабатываются в `GameModeService`.
    - `draw() -> dict`: (Унаследован от `Entity`) Возвращает данные для отрисовки. Может быть расширен для включения специфичных для игрока данных, если потребуется.

- **Взаимодействие и логика:**
    - Игрок создается и добавляется в игру через `GameCoordinator` и `GameService`.
    - Команды ввода от клиента поступают через NATS, обрабатываются `GameCoordinator` и передаются в `player.set_inputs()`.
    - Движение игрока, применение оружия, получение урона и другие взаимодействия с игровым миром обрабатываются в соответствующем `GameModeService` на основе состояния игрока и его ввода. 

## 8. Враг (`Enemy`)

Файл: `app/entities/enemy.py`

Класс `Enemy` представляет собой управляемого искусственным интеллектом (AI) противника на игровой карте.

### 8.1. Типы Врагов (`EnemyType`)

Перечисление `EnemyType` определяет различные типы врагов, которые могут встретиться в игре.

- **Значения:**
    - `COIN`: Вероятно, простой тип врага (возможно, используется для отладки или как базовый тип).
    - `BEAR`: Тип врага "Медведь".
    - `GHOST`: Тип врага "Призрак".

### 8.2. Класс Врага (`Enemy`)

- **Наследование:** `Entity`
- **Статические атрибуты:**
    - `ENEMY_LIVES` (dict[EnemyType, int]): Словарь, сопоставляющий каждому `EnemyType` начальное количество жизней (например, `EnemyType.BEAR: 3`).

- **Основные атрибуты (в дополнение к унаследованным):**
    - `type` (`EnemyType`): Конкретный тип врага.
    - `lives` (int): Текущее количество жизней (инициализируется из `ENEMY_LIVES` на основе `self.type`).
    - `move_timer` (float): Таймер, используемый для отслеживания времени с последней смены направления движения.
    - `change_direction_interval` (float): Случайно определяемый интервал времени, через который враг меняет направление своего движения.
    - `direction` (tuple[float, float]): Нормализованный вектор `(dx, dy)`, указывающий текущее направление движения врага (выбирается случайно из четырех кардинальных направлений).
    - `destroyed` (bool): Флаг, указывающий, что враг уничтожен (и, возможно, ожидает завершения анимации уничтожения).
    - `destroy_animation_timer` (float): Таймер для отслеживания длительности анимации уничтожения врага.

- **Основные методы:**
    - `__init__(x, y, size, speed, enemy_type)`: Инициализирует врага с указанными параметрами, устанавливает `ai=True`, присваивает тип, жизни и начальное случайное направление.
    - `get_random_direction() -> tuple[float, float]`: Возвращает случайный нормализованный вектор направления из четырех возможных: (0,1), (1,0), (0,-1), (-1,0).
    - `update(delta_time: float) -> None`: (Не реализован в `Enemy`, но унаследован от `Entity`) Базовый `Entity.update` обрабатывает неуязвимость. Логика движения врага, смена направления на основе `move_timer` и `change_direction_interval`, а также обработка столкновений и уничтожения, выполняются в `GameModeService` (например, в методе `update_enemy`).

- **Логика AI и поведения:**
    - Базовый AI врагов (случайное движение) реализуется в `GameModeService`.
    - `GameModeService` обновляет позицию врага на основе его `speed` и `direction`.
    - Когда `move_timer` врага превышает его `change_direction_interval`, `GameModeService` вызывает `enemy.get_random_direction()` для получения нового направления и сбрасывает `move_timer`.
    - При получении урона жизни врага уменьшаются. Когда жизни достигают нуля, враг помечается как `destroyed`, и запускается `destroy_animation_timer`. 

## 9. Игровая Карта (`Map`)

Файл: `app/entities/map.py`

Класс `Map` представляет игровую карту (уровень) в сервисе. Он хранит информацию о сетке карты, ее размерах и предоставляет методы для взаимодействия с ячейками карты.

- **Основные атрибуты:**
    - `width` (int): Ширина карты в клетках.
    - `height` (int): Высота карты в клетках.
    - `grid` (`numpy.ndarray`): Двумерный массив NumPy (типа `int8`), представляющий сетку карты. Каждое значение в массиве соответствует `CellType` (например, `CellType.EMPTY`, `CellType.SOLID_WALL`).
    - `changed_cells` (List[Dict[str, int]]): Список словарей, отслеживающий изменения ячеек на карте. Каждое изменение записывается как `{'x': x, 'y': y, 'type': int(cell_type)}`. Это используется для отправки клиентам только дельты изменений карты, а не всей карты целиком при каждом обновлении.

- **Основные методы:**
    - `__init__(width: int, height: int)`: Инициализирует карту с заданными размерами, создавая пустую сетку (`grid`), заполненную нулями (`CellType.EMPTY`).
    - `load_from_template(grid_data: List[List[int]]) -> None`: Загружает структуру карты из предоставленного шаблона `grid_data` (список списков целых чисел). Проверяет соответствие размеров и конвертирует данные в `numpy.ndarray`. Сбрасывает `changed_cells`.
    - `get_cell_type(x: int, y: int) -> CellType`: Возвращает `CellType` ячейки по заданным координатам `(x, y)`. Если координаты выходят за пределы карты, возвращает `CellType.SOLID_WALL`.
    - `set_cell_type(x: int, y: int, cell_type: CellType) -> None`: Устанавливает указанный `cell_type` для ячейки `(x, y)`. Если тип ячейки действительно изменился, добавляет информацию об изменении в `self.changed_cells`.
    - `is_wall(x, y)`, `is_breakable_block(x, y)`, `is_solid(x, y)`, `is_empty(x, y)`, `is_player_spawn(x, y)`, `is_enemy_spawn(x, y)`: Серия булевых методов-хелперов для быстрой проверки типа конкретной ячейки.
    - `destroy_block(x: int, y: int) -> bool`: Если ячейка `(x, y)` является разрушаемым блоком (`CellType.BREAKABLE_BLOCK`), изменяет ее тип на `CellType.EMPTY` (через `set_cell_type`, что также регистрирует изменение) и возвращает `True`. Иначе `False`.
    - `get_empty_cells(...) -> List[Tuple[int, int]]`: Возвращает список кортежей `(x, y)` всех пустых ячеек на карте. Имеет опциональные параметры для исключения ячеек, находящихся слишком близко к позициям спавна игроков.
    - `get_player_spawn_positions() -> List[Tuple[int, int]]`: Возвращает список координат `(x, y)` всех ячеек типа `CellType.PLAYER_SPAWN`.
    - `get_enemy_spawn_positions(...) -> List[Tuple[int, int]]`: Возвращает список координат `(x, y)` всех ячеек типа `CellType.ENEMY_SPAWN`, с возможностью исключения позиций рядом с игроками.
    - `get_map() -> Dict`: Возвращает словарь с полным представлением карты: `{'grid': self.grid.tolist(), 'width': self.width, 'height': self.height}`.
    - `clear_changes() -> None`: Очищает список `self.changed_cells`.
    - `get_changes() -> List[Dict[str, int]]`: (Предположительно, на основе неполного кода) Возвращает текущий список `self.changed_cells` и затем очищает его.

- **Использование NumPy:** Применение `numpy.ndarray` для хранения сетки карты позволяет эффективно выполнять операции над картой, такие как поиск ячеек определенного типа.
- **Генерация и загрузка:** Класс `Map` сам по себе не содержит логики генерации случайных карт или сложной загрузки из файлов. Эта логика обычно находится в `MapService`, который использует экземпляр `Map` для хранения и изменения данных карты. 