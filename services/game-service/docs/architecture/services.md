# Сервисный слой

Сервисный слой Game Service содержит основную бизнес-логику приложения. Он отвечает за управление игровым процессом, обработку событий, взаимодействие с данными и генерацию карт.

## 1. `GameCoordinator` (`app/coordinators/game_coordinator.py`)

`GameCoordinator` является центральным оркестратором для всех активных игровых сессий.

**Основные обязанности:**

-   **Управление жизненным циклом игр**: Хранит словарь активных игр (`self.games: dict[str, GameService]`), добавляет новые игры при получении события `game.create` и удаляет завершенные игры.
-   **Обработка NATS событий**: Подписывается на основные игровые NATS-события (`game.create`, `game.join`, `game.input` и др.) через `EventService`. При получении события, он делегирует его обработку соответствующему экземпляру `GameService` или выполняет действие сам (например, создание новой игры).
-   **Игровой цикл (`start_game_loop`)**: Запускает асинхронный цикл, который с заданной частотой (`settings.GAME_UPDATE_FPS`):
    -   Итерируется по всем активным играм.
    -   Вызывает метод `game.update()` для каждой активной игры.
    -   Отправляет обновленное состояние игры (`updated_state`) всем клиентам данной игры через NATS (`game.update.{game_id}`).
    -   Если игра становится неактивной (например, завершена или нет игроков), отправляет событие `game.over.{game_id}` и удаляет игру из списка активных.
-   **Инициализация обработчиков**: В `initialize_handlers()` регистрирует колбэки (свои методы) для каждого NATS-события в `EventService`.

**Ключевые методы-обработчики NATS событий:**

-   `game_create(**kwargs)`: Создает новый экземпляр `GameService` с указанными настройками (`GameCreateSettings` или отдельные параметры), инициализирует его (`game_service.initialize_game()`) и добавляет в словарь `self.games`.
-   `game_join(**kwargs)`: Находит игру по `game_id`, вызывает `game.add_player()` и возвращает результат вместе с начальным состоянием игры.
-   `game_input(**kwargs)`: Находит игру и игрока, вызывает `player.set_inputs()`.
-   `game_place_bomb(**kwargs)`: (Для совместимости) Находит игру и игрока, вызывает `game.apply_weapon()` с типом `WeaponType.BOMB`.
-   `game_apply_weapon(**kwargs)`: Находит игру и игрока, вызывает `game.apply_weapon()` с указанным или основным типом оружия.
-   `game_get_state(**kwargs)`: Находит игру, вызывает `game.get_state()` и добавляет к нему полную карту.
-   `game_player_disconnect(**kwargs)`: Находит игру, вызывает `game.remove_player()`.

## 2. `EventService` (`app/services/event_service.py`)

`EventService` предоставляет абстракцию для работы с NATS, упрощая подписку на события и их публикацию.

**Основные обязанности:**

-   **Подписка на события**: Метод `subscribe_handler(event: NatsEvents, callback: Callable)` позволяет подписываться на определенные `NatsEvents`. Он оборачивает предоставленный `callback` (обычно метод из `GameCoordinator`) в `callback_wrapper`, который декодирует входящее сообщение из JSON, вызывает `callback` и, если сообщение NATS имело поле `reply`, отправляет результат обратно.
-   **Публикация событий**: Предоставляет методы для отправки типизированных игровых событий:
    -   `send_game_update(game_id: str, data: dict)`: Отправляет событие `game.update.{game_id}`.
    -   `send_game_over(game_id: str)`: Отправляет событие `game.over.{game_id}`.
    -   Использует `NatsRepository` для фактической отправки сообщений.
-   **Обработка ошибок**: В `callback_wrapper` перехватывает исключения при обработке событий и отправляет сообщение об ошибке, если был указан `msg.reply`.
-   **Вспомогательные обработчики (`handle_...`)**: Содержат логику вызова переданного `callback` для каждого типа события и формирования ответа.

## 3. `GameService` (`app/services/game_service.py`)

`GameService` инкапсулирует логику одной игровой сессии.

**Основные обязанности:**

-   **Управление состоянием игры**: Хранит текущий статус игры (`GameStatus`: PENDING, ACTIVE, FINISHED и др.).
-   **Игровой режим**: При инициализации создает и хранит экземпляр конкретного игрового режима (`GameModeService`), который соответствует настройкам игры (`self.settings.game_mode`).
-   **Инициализация игры (`initialize_game`)**: Делегирует инициализацию карты текущему игровому режиму (`self.game_mode.initialize_map()`).
-   **Управление игроками**: Методы `add_player()`, `remove_player()`, `get_player()` делегируют вызовы соответствующим методам игрового режима.
-   **Управление игровым процессом**: Методы `start_game()`, `pause_game()`, `resume_game()` изменяют статус игры.
-   **Обновление состояния (`update`)**: Если игра активна, делегирует вызов `self.game_mode.update()`. Если режим сообщает, что игра окончена (`self.game_mode.game_over`), обновляет статус игры на `FINISHED`.
-   **Применение оружия (`apply_weapon`)**: Находит игрока и делегирует применение оружия игровому режиму.
-   **Получение состояния (`get_state`)**: Получает состояние от игрового режима и добавляет к нему общий статус игры и режим.
-   **Проверка активности (`is_active`)**: Проверяет, активна ли игра и есть ли игроки (делегирует `game_mode.is_active()`).

## 4. `GameModeService` и его реализации (`app/services/game_mode_service.py`, `app/services/modes/`)

`GameModeService` — это абстрактный базовый класс, определяющий интерфейс для различных игровых режимов. Конкретные режимы наследуются от него.

**Общие для всех режимов (в `GameModeService`):**

-   Хранение состояния: `players`, `teams`, `enemies`, `weapons`, `power_ups`, `map`, `score`, `level`, `game_over`.
-   Инициализация карты (`initialize_map`): Загружает карту из шаблона/цепочки через `MapService` или генерирует случайную, создает врагов.
-   Базовое добавление/удаление игрока (размещение на карте, назначение цвета).
-   Обновление состояния (`update`): Вычисляет `delta_time`, обновляет игроков, врагов, оружие. Проверяет, не окончена ли игра.
-   Логика обновления отдельных сущностей: `update_player`, `update_enemy`, `update_weapon`.
-   Обработка столкновений: `check_collision` (с картой и статическими объектами), `check_entity_collision` (между двумя сущностями), `check_explosion_collision`.
-   Обработка попаданий: `handle_player_hit`, `handle_enemy_hit`.
-   Механика оружия: `apply_weapon` (создание бомб, пуль, мин), `handle_bomb_explosion`.
-   Механика усилений: `spawn_power_up`, `apply_power_up`.
-   Получение полного состояния игры для отправки клиентам (`get_state`).

**Абстрактные методы (должны быть реализованы в подклассах):**

-   `is_game_over() -> bool`: Проверка специфичных для режима условий окончания игры.
-   `handle_game_over() -> None`: Действия при завершении игры (например, определение победителя).
-   `setup_teams() -> None`: Настройка команд в соответствии с правилами режима.

**Реализации игровых режимов:**

-   **`CampaignMode` (`app/services/modes/campaign_mode.py`)**
    -   Все игроки в одной команде (`team_1`).
    -   Игра заканчивается, если все игроки мертвы или все враги на уровне убиты.
    -   При убийстве всех врагов происходит переход на следующий уровень (`_level_complete`): инкремент уровня, начисление очков, сброс карты, оружия, усилений, респавн игроков.
-   **`FreeForAllMode` (`app/services/modes/free_for_all_mode.py`)**
    -   Каждый игрок находится в своей собственной команде.
    -   Враги по умолчанию отключены (`self.settings.enable_enemies = False`).
    -   Игра заканчивается, когда остается один живой игрок или истекает время.
-   **`CaptureFlagMode` (`app/services/modes/capture_flag_mode.py`)**
    -   Количество команд определяется настройками карты или игры (пока фиксировано 2+).
    -   Враги отключены.
    -   Логика флагов и их захвата не полностью детализирована, но есть структура для `flag_positions`, `team_flags`, `captured_flags`.
    -   Игра заканчивается по лимиту очков (захваченных флагов) или по времени.
    -   Есть базовая логика распределения игроков по командам.

## 5. `MapService` (`app/services/map_service.py`)

`MapService` отвечает за все операции, связанные с картами.

**Основные обязанности:**

-   **Создание карт из источников**: 
    -   `create_map_from_template(template_id)`: Загружает шаблон карты из `MapRepository` и создает на его основе объект `Map`.
    -   `create_map_from_chain(chain_id, level_index)`: Загружает цепочку карт, выбирает нужный шаблон по индексу уровня и создает карту.
    -   `create_map_from_group(group_id)`: Загружает группу карт, случайно выбирает один шаблон и создает карту.
-   **Генерация случайных карт (`generate_random_map`)**: 
    -   Создает объект `Map` с заданными размерами.
    -   Добавляет границы (`_add_border_walls`).
    -   Добавляет внутренние стены (в шахматном порядке `_add_internal_walls` или "змейкой" `_add_snake_walls` в зависимости от `game_settings.enable_snake_walls`).
    -   Размещает точки спавна игроков (`_add_player_spawns`), стараясь использовать углы и распределять игроков.
    -   Размещает разрушаемые блоки (`_add_breakable_blocks`) со случайной вероятностью, зависящей от сложности, избегая зон рядом с игроками.
    -   Размещает точки спавна врагов (`_add_enemy_spawns`) на пустых клетках с учетом настроек (`allow_enemies_near_players`, `min_distance_from_players`).
-   **Генерация врагов для уровня (`generate_enemies_for_level`)**: 
    -   Определяет количество и типы врагов на основе номера уровня и настроек игры (`game_settings.enemy_count_multiplier`).
    -   Выбирает случайные позиции для спавна врагов из доступных на карте.

`MapService` тесно взаимодействует с `MapRepository` для получения данных о шаблонах, группах и цепочках карт, а также с `GameSettings` для учета параметров генерации. 