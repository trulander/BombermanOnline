[![English](https://img.shields.io/badge/lang-English-blue)](../../en/architecture/overview.md)

# Обзор архитектуры Game Service

Game Service построен с использованием многослойной архитектуры, направленной на разделение ответственностей и обеспечение модульности. Основные компоненты взаимодействуют через четко определенные интерфейсы и события.

## Ключевые слои и компоненты:

1.  **Точка входа и маршрутизация (`app/main.py`, `app/routes/`)**:
    -   **FastAPI приложение (`app/main.py`)**: Инициализирует приложение, middleware (CORS, Prometheus, Auth), подключает роутеры и управляет жизненным циклом (startup/shutdown события для инициализации/освобождения ресурсов, таких как подключения к БД и NATS).
    -   **Роутеры (`app/routes/map_routes.py`)**: Определяют HTTP эндпоинты для взаимодействия с сервисом (например, CRUD операции для управления картами). Обрабатывают HTTP запросы, валидируют данные и вызывают соответствующие сервисы.

2.  **Координаторы (`app/coordinators/`)**:
    -   **`GameCoordinator`**: Центральный компонент, управляющий жизненным циклом игр. Он:
        -   Подписывается на NATS события (создание игры, подключение игрока, ввод и т.д.) через `EventService`.
        -   Управляет словарем активных игр (`games: dict[str, GameService]`).
        -   Запускает и поддерживает основной игровой цикл (`start_game_loop`), который периодически обновляет состояние всех активных игр и рассылает обновления через NATS.
        -   Обрабатывает создание, присоединение, ввод, применение оружия, запросы состояния и отключения игроков, делегируя эти операции соответствующему экземпляру `GameService`.

3.  **Сервисный слой (`app/services/`)**:
    -   **`EventService`**: Абстракция для работы с NATS. Регистрирует обработчики для входящих NATS-сообщений и предоставляет методы для публикации исходящих событий. Декодирует входящие сообщения и кодирует исходящие.
    -   **`GameService`**: Управляет логикой одной игровой сессии. Содержит экземпляр конкретного игрового режима (`GameModeService`). Отвечает за добавление/удаление игроков, запуск/паузу/возобновление игры, обновление состояния через вызов `game_mode.update()`, применение оружия.
    -   **`GameModeService` (и его реализации в `app/services/modes/`)**: Абстрактный базовый класс для различных игровых режимов (`CampaignMode`, `FreeForAllMode`, `CaptureTheFlagMode`). Каждый режим реализует специфичную логику:
        -   Инициализация карты (`initialize_map`).
        -   Добавление/удаление игроков с учетом правил режима.
        -   Обновление состояния игровых объектов (игроки, враги, оружие).
        -   Проверка условий окончания игры (`is_game_over`).
        -   Обработка завершения игры (`handle_game_over`).
        -   Настройка команд (`setup_teams`).
        -   Управление столкновениями, очками, ИИ врагов, усилениями.
    -   **`MapService`**: Отвечает за создание и генерацию карт. Может загружать карты из шаблонов (через `MapRepository`), из цепочек карт или генерировать случайные карты с различными параметрами (стены, спавны, разрушаемые блоки, враги).

4.  **Слой доступа к данным (Репозитории - `app/repositories/`)**:
    -   **`NatsRepository`**: Низкоуровневая обертка для взаимодействия с NATS (подключение, публикация, подписка). Используется `EventService`.
    -   **`RedisRepository`**: Обертка для взаимодействия с Redis (set, get, delete). Используется `MapRepository` для кеширования.
    -   **`PostgresRepository`**: Обертка для взаимодействия с PostgreSQL с использованием SQLAlchemy (асинхронные сессии). Используется `MapRepository`.
    -   **`MapRepository`**: Управляет хранением и извлечением данных о картах (шаблоны, группы, цепочки). Взаимодействует с PostgreSQL для персистентного хранения и с Redis для кеширования.

5.  **Модели данных (`app/models/`)**:
    -   **Pydantic модели**: Используются для валидации данных в API запросах/ответах (`MapTemplateCreate`, `MapTemplateUpdate` и т.д.) и для настроек игры (`GameCreateSettings`).
    -   **SQLAlchemy ORM модели (`MapTemplateORM`, `MapGroupORM`, `MapChainORM`)**: Определяют структуру таблиц в базе данных PostgreSQL для хранения информации о картах.

6.  **Игровые сущности (`app/entities/`)**:
    -   Классы, представляющие все игровые объекты: `Player`, `Enemy`, `Bomb`, `Bullet`, `Mine`, `PowerUp`, `Map`, `CellType`, `GameSettings`, `Weapon`, `UnitType` и т.д.
    -   Они содержат состояние и базовую логику поведения объектов (например, `Player.set_inputs()`, `Bomb.update()`).

7.  **Конфигурация и Утилиты**:
    -   `app/config.py`: Загрузка настроек приложения из переменных окружения.
    -   `app/logging_config.py`: Настройка системы логирования.
    -   `app/auth.py`: Функции-зависимости для проверки аутентификации/авторизации в эндпоинтах.

## Потоки данных (упрощенно)

-   **HTTP Запросы (Управление картами)**: Клиент -> `map_routes.py` -> `MapRepository` -> PostgreSQL/Redis.
-   **NATS Команды (Игровые действия)**: Клиент -> NATS -> `EventService` -> `GameCoordinator` -> `GameService` -> `GameModeService` -> Обновление сущностей -> `GameCoordinator` рассылает `game.update` через `EventService` -> NATS -> Клиенты.

Эта архитектура стремится к слабой связанности компонентов и высокой расширяемости, позволяя добавлять новые игровые режимы, типы карт или сущностей с минимальным воздействием на другие части системы.