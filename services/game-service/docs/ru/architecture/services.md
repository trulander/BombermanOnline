[![English](https://img.shields.io/badge/lang-English-blue)](../../en/architecture/services.md)

# Сервисный слой

Сервисный слой Game Service содержит основную бизнес-логику приложения. Он отвечает за управление игровым процессом, обработку событий, взаимодействие с данными, генерацию карт и управление командами.

## 1. `GameCoordinator` (`app/coordinators/game_coordinator.py`)

`GameCoordinator` является центральным оркестратором для всех активных игровых сессий.

**Основные обязанности:**

-   **Управление жизненным циклом игр**: Хранит словарь активных игр (`self.games: dict[str, GameService]`), добавляет новые игры при получении события `game.create` и удаляет завершенные игры.
-   **Обработка NATS событий**: Подписывается на основные игровые NATS-события (`game.create`, `game.join`, `game.input` и др.) через `EventService`. При получении события, он делегирует его обработку соответствующему экземпляру `GameService` или выполняет действие сам (например, создание новой игры).
-   **Игровой цикл (`start_game_loop`)**: Запускает асинхронный цикл, который с заданной частотой (`settings.GAME_UPDATE_FPS`):
    -   Итерируется по всем активным играм.
    -   Вызывает метод `game.update()` для каждой активной игры.
    -   Отправляет обновленное состояние игры (`updated_state`) всем клиентам данной игры через NATS (`game.update.{game_id}`).
    -   Если игра становится неактивной (например, завершена или нет игроков), отправляет событие `game.over.{game_id}` и удаляет игру из списка активных.
-   **Инициализация обработчиков**: В `initialize_handlers()` регистрирует колбэки (свои методы) для каждого NATS-события в `EventService`.

**Ключевые методы-обработчики NATS событий:**

-   `game_create(**kwargs)`: Создает новый экземпляр `GameService` с указанными настройками (`GameCreateSettings` или отдельные параметры), инициализирует его (`game_service.initialize_game()`) и добавляет в словарь `self.games`.
-   `game_join(**kwargs)`: Находит игру по `game_id`, вызывает `game.add_player()` и возвращает результат вместе с начальным состоянием игры.
-   `game_input(**kwargs)`: Находит игру и игрока, вызывает `player.set_inputs()`.
-   `game_place_weapon(**kwargs)`: Находит игру и игрока, вызывает `game.place_weapon()` с указанным или основным типом оружия.
-   `game_get_state(**kwargs)`: Находит игру, вызывает `game.get_state()` и добавляет к нему полную карту.
-   `game_player_disconnect(**kwargs)`: Находит игру, вызывает `game.remove_player()`.

## 2. `EventService` (`app/services/event_service.py`)

`EventService` предоставляет абстракцию для работы с NATS, упрощая подписку на события и их публикацию.

**Основные обязанности:**

-   **Подписка на события**: Метод `subscribe_handler(event: NatsEvents, callback: Callable)` позволяет подписываться на определенные `NatsEvents`. Он оборачивает предоставленный `callback` (обычно метод из `GameCoordinator`) в `callback_wrapper`, который декодирует входящее сообщение из JSON, вызывает `callback` и, если сообщение NATS имело поле `reply`, отправляет результат обратно.
-   **Публикация событий**: Предоставляет методы для отправки типизированных игровых событий:
    -   `send_game_update(game_id: str, data: dict)`: Отправляет событие `game.update.{game_id}`.
    -   `send_game_over(game_id: str)`: Отправляет событие `game.over.{game_id}`.
    -   Использует `NatsRepository` для фактической отправки сообщений.
-   **Обработка ошибок**: В `callback_wrapper` перехватывает исключения при обработке событий и отправляет сообщение об ошибке, если был указан `msg.reply`.
-   **Вспомогательные обработчики (`handle_...`)**: Содержат логику вызова переданного `callback` для каждого типа события и формирования ответа.

## 3. `GameService` (`app/services/game_service.py`)

`GameService` инкапсулирует логику одной игровой сессии.

**Основные обязанности:**

-   **Управление состоянием игры**: Хранит текущий статус игры (`GameStatus`: PENDING, ACTIVE, FINISHED и др.).
-   **Управление командами**: Создает и инициализирует `TeamService` для управления командами игры на основе игрового режима.
-   **Игровой режим**: При инициализации создает и хранит экземпляр конкретного игрового режима (`GameModeService`), который соответствует настройкам игры (`self.settings.game_mode`). `TeamService` передается в конструктор игрового режима.
-   **Инициализация игры (`initialize_game`)**: Настраивает команды по умолчанию через `TeamService` и делегирует инициализацию карты текущему игровому режиму (`self.game_mode.initialize_map()`).
-   **Управление игроками**: Методы `add_player()`, `remove_player()`, `get_player()` делегируют вызовы соответствующим методам игрового режима. При добавлении игрока автоматически выполняется распределение по командам.
-   **Управление игровым процессом**: Методы `start_game()`, `pause_game()`, `resume_game()` изменяют статус игры. При запуске проверяется корректность настройки команд.
-   **Обновление состояния (`update`)**: Если игра активна, делегирует вызов `self.game_mode.update()`. Если режим сообщает, что игра окончена (`self.game_mode.game_over`), обновляет статус игры на `FINISHED`.
-   **Применение оружия (`place_weapon`)**: Находит игрока и делегирует применение оружия игровому режиму.
-   **Получение состояния (`get_state`)**: Получает состояние от игрового режима, добавляет к нему общий статус игры, режим и состояние команд от `TeamService`.
-   **Проверка активности (`is_active`)**: Проверяет, активна ли игра и есть ли игроки (делегирует `game_mode.is_active()`).

## 4. `TeamService` (`app/services/team_service.py`)

`TeamService` управляет командами в рамках одной игровой сессии.

**Основные обязанности:**

-   **Управление командами**: Создание, обновление, удаление команд. Хранит команды в словаре `teams: Dict[str, Team]`.
-   **Управление игроками в командах**: Добавление и удаление игроков из команд с проверкой лимитов и ограничений игрового режима.
-   **Автоматическое распределение игроков**: Реализует алгоритмы распределения игроков по командам в зависимости от игрового режима:
    -   **CAMPAIGN**: Все игроки в одной команде.
    -   **FREE_FOR_ALL**: Каждый игрок в отдельной команде.
    -   **CAPTURE_THE_FLAG**: Равномерное распределение по 2-4 командам.
-   **Настройки по игровому режиму**: Использует `TeamModeSettings` из `TEAM_MODE_SETTINGS` для определения правил формирования команд.
-   **Командная система очков**: Начисление очков командам игроков за различные игровые достижения.
-   **Валидация команд**: Проверка корректности настройки команд перед началом игры.

**Ключевые методы:**

-   `create_team(team_name, team_id=None)`: Создает новую команду с проверкой лимитов.
-   `add_player_to_team(team_id, player_id)`: Добавляет игрока в команду, удаляя его из других команд.
-   `remove_player_from_team(team_id, player_id)`: Удаляет игрока из команды.
-   `auto_distribute_players(players, redistribute_existing=False)`: Автоматически распределяет игроков по командам согласно правилам режима.
-   `setup_default_teams()`: Создает команды по умолчанию для текущего игрового режима.
-   `add_score_to_player_team(player_id, points)`: Начисляет очки команде игрока.
-   `validate_teams()`: Возвращает список ошибок валидации команд.
-   `get_teams_state()`: Возвращает состояние всех команд для API.

## 5. `GameModeService` и его реализации (`app/services/game_mode_service.py`, `app/services/modes/`)

`GameModeService` — это абстрактный базовый класс, определяющий интерфейс для различных игровых режимов. Конкретные режимы наследуются от него.

**Общие для всех режимов (в `GameModeService`):**

-   Хранение состояния: `players`, `enemies`, `weapons`, `power_ups`, `map`, `score`, `level`, `game_over`.
-   **Интеграция с командами**: Принимает `TeamService` в конструкторе и использует его для командной системы очков.
-   Инициализация карты (`initialize_map`): Загружает карту из шаблона/цепочки через `MapService` или генерирует случайную, создает врагов.
-   Базовое добавление/удаление игрока (размещение на карте, назначение цвета).
-   Обновление состояния (`update`): Вычисляет `delta_time`, обновляет игроков, врагов, оружие. Проверяет, не окончена ли игра.
-   Логика обновления отдельных сущностей: `update_player`, `update_enemy`, `update_weapon`.
-   Обработка столкновений: `check_collision` (с картой и статическими объектами), `check_entity_collision` (между двумя сущностями), `check_explosion_collision`.
-   **Командная система очков**: `handle_player_hit`, `handle_enemy_hit`, `apply_power_up`, `handle_bomb_explosion` теперь начисляют очки командам через `TeamService` вместо глобального счета.
-   Механика оружия: `place_weapon` (создание бомб, пуль, мин), `handle_bomb_explosion`.
-   Механика усилений: `spawn_power_up`, `apply_power_up`.
-   Получение полного состояния игры для отправки клиентам (`get_state`).

**Абстрактные методы (должны быть реализованы в подклассах):**

-   `is_game_over() -> bool`: Проверка специфичных для режима условий окончания игры.
-   `handle_game_over() -> None`: Действия при завершении игры (например, определение победителя).
-   `setup_teams() -> None`: Настройка команд в соответствии с правилами режима (теперь делегируется `TeamService`).

**Реализации игровых режимов:**

-   **`CampaignMode` (`app/services/modes/campaign_mode.py`)**
    -   Команды настраиваются через `TeamService` (все игроки в одной команде).
    -   Игра заканчивается, если все игроки мертвы или все враги на уровне убиты.
    -   При убийстве всех врагов происходит переход на следующий уровень (`_level_complete`): инкремент уровня, начисление очков команде, сброс карты, оружия, усилений, респавн игроков.
-   **`FreeForAllMode` (`app/services/modes/free_for_all_mode.py`)**
    -   Команды настраиваются через `TeamService` (каждый игрок в своей команде).
    -   Враги по умолчанию отключены (`self.settings.enable_enemies = False`).
    -   Игра заканчивается, когда остается один живой игрок или истекает время.
    -   Победитель получает очки через командную систему.
-   **`CaptureFlagMode` (`app/services/modes/capture_flag_mode.py`)**
    -   Команды настраиваются через `TeamService` (2-4 команды с балансированным распределением).
    -   Враги отключены.
    -   Логика флагов и их захвата не полностью детализирована, но есть структура для `flag_positions`, `team_flags`, `captured_flags`.
    -   Игра заканчивается по лимиту очков команды или по времени.
    -   Использует командную систему очков для определения победителя.

## 6. `MapService` (`app/services/map_service.py`)

`MapService` отвечает за все операции, связанные с картами.

**Основные обязанности:**

-   **Создание карт из источников**: 
    -   `create_map_from_template(template_id)`: Загружает шаблон карты из `MapRepository` и создает на его основе объект `Map`.
    -   `create_map_from_chain(chain_id, level_index)`: Загружает цепочку карт, выбирает нужный шаблон по индексу уровня и создает карту.
    -   `create_map_from_group(group_id)`: Загружает группу карт, случайно выбирает один шаблон и создает карту.
-   **Генерация случайных карт (`generate_random_map`)**: 
    -   Создает объект `Map` с заданными размерами.
    -   Добавляет границы (`_add_border_walls`).
    -   Добавляет внутренние стены (в шахматном порядке `_add_internal_walls` или "змейкой" `_add_snake_walls` в зависимости от `game_settings.enable_snake_walls`).
    -   Размещает точки спавна игроков (`_add_player_spawns`), стараясь использовать углы и распределять игроков.
    -   Размещает разрушаемые блоки (`_add_breakable_blocks`) со случайной вероятностью, зависящей от сложности, избегая зон рядом с игроками.
    -   Размещает точки спавна врагов (`_add_enemy_spawns`) на пустых клетках с учетом настроек (`allow_enemies_near_players`, `min_distance_from_players`).
-   **Генерация врагов для уровня (`generate_enemies_for_level`)**: 
    -   Определяет количество и типы врагов на основе номера уровня и настроек игры (`game_settings.enemy_count_multiplier`).
    -   Выбирает случайные позиции для спавна врагов из доступных на карте.

`MapService` тесно взаимодействует с `MapRepository` для получения данных о шаблонах, группах и цепочках карт, а также с `GameSettings` для учета параметров генерации.