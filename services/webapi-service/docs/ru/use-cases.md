# Сценарии использования (Use Cases)
[![English](https://img.shields.io/badge/lang-English-blue)](../en/use-cases.md)

В этом разделе подробно рассматриваются основные сценарии взаимодействия пользователя с системой через `WebAPI Service`.

## Сценарий 1: Создание и запуск новой игры

**Цель:** Пользователь хочет создать новую игровую комнату и начать игру.

**Действующие лица:** Клиент (пользователь), WebAPI Service, Game Allocator Service, Game Service.

**Шаги:**

1.  **Пользователь** нажимает кнопку "Создать игру" в интерфейсе клиента.
2.  **Клиент** отправляет `POST` запрос на эндпоинт `/api/v1/games`.
    *   **Тело запроса** содержит параметры игры: режим (`game_mode`), максимальное количество игроков (`max_players`) и т.д.
    ```json
    {
      "game_mode": "FREE_FOR_ALL",
      "max_players": 4
    }
    ```
3.  **WebAPI Service** (`game_routes.py`) принимает запрос.
4.  Вызывается `GameService.create_game()`, который инициирует процесс выделения игрового сервера через NATS (см. диаграмму в разделе [Взаимодействие](./interactions.md)).
5.  После того как `Game Allocator` выделил экземпляр `Game Service` и тот подтвердил создание комнаты, WebAPI возвращает клиенту успешный ответ.
    *   **Тело ответа** содержит `game_id`.
    ```json
    {
      "success": true,
      "game_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
    }
    ```
6.  **Клиент** получает `game_id` и автоматически инициирует WebSocket-соединение с сервером.
7.  После установки соединения клиент отправляет событие `join_game`.
    ```javascript
    // Пример на клиенте
    const socket = io("http://localhost:5001");
    socket.emit("join_game", { game_id: "a1b2c3d4-..." }, (response) => {
      if (response.success) {
        console.log("Успешно присоединились к игре! Player ID:", response.player_id);
        // Начать игровой процесс
      }
    });
    ```
8.  **WebAPI Service** (`socketio_service.py`) обрабатывает `join_game`, связывает `sid` клиента с `game_id`, подписывается на обновления от `Game Service` через NATS и добавляет клиента в комнату Socket.IO для данной игры.
9.  Игра готова к началу. Клиент может отправлять команды ввода и будет получать обновления состояния.

## Сценарий 2: Игровой процесс

**Цель:** Пользователь, находясь в игре, управляет своим персонажем и видит действия других игроков.

**Действующие лица:** Клиент, WebAPI Service, Game Service, NATS.

**Предусловие:** Пользователь успешно присоединился к игре (Сценарий 1).

**Шаги:**

1.  **Пользователь** нажимает клавишу движения (например, "вверх").
2.  **Клиент** фиксирует это действие и отправляет событие `input` через WebSocket.
    ```javascript
    socket.emit("input", {
      game_id: "a1b2c3d4-...",
      inputs: { up: true, down: false, left: false, right: false }
    });
    ```
3.  **WebAPI Service** (`socketio_service.py`) получает событие и вызывает `GameService.send_input()`.
4.  `GameService` через `NatsService` публикует команду `game.input` в NATS, адресуя ее конкретному экземпляру `Game Service`, который обслуживает игру.
5.  **Game Service** получает команду, обновляет позицию персонажа в своем внутреннем состоянии.
6.  После обновления своего состояния **Game Service** публикует полное или частичное состояние игры в тему `game.update.{game_id}` в NATS.
7.  **WebAPI Service** (`nats_service.py`), будучи подписанным на эту тему, получает обновление.
8.  `NatsService` вызывает соответствующий обработчик в `SocketIOService` (`handle_game_update`).
9.  **SocketIOService** отправляет событие `game_update` всем клиентам, находящимся в комнате данной игры.
    ```javascript
    // Клиент слушает событие
    socket.on("game_update", (gameState) => {
      // Обновить канвас, перерисовать всех игроков и объекты
      console.log("Новое состояние игры:", gameState);
      renderGame(gameState);
    });
    ```
10. **Клиент** получает новое состояние и перерисовывает игровой мир, отображая движение персонажа.

Этот цикл повторяется для каждого действия каждого игрока, обеспечивая синхронизацию игры в реальном времени.

## Сценарий 3: Просмотр статистики завершенной игры

**Цель:** Пользователь хочет посмотреть детальную статистику после окончания матча.

**Действующие лица:** Клиент, WebAPI Service, Game Service.

**Предусловие:** Игра завершена.

**Шаги:**

1.  **Клиент** переходит на экран результатов матча.
2.  Для получения подробных данных (например, кто кого победил, точность и т.д.) клиент отправляет `GET` запрос на прокси-эндпоинт.
    *   **URL запроса**: `/api/v1/game-service/{game_id}/statistics`
3.  **WebAPI Service** (`proxy_routes.py`) обрабатывает запрос.
4.  Он извлекает `game_id` и ищет в **Redis-кэше** адрес (`instance_id`) `Game Service`, который обслуживал эту игру.
5.  Найдя адрес, WebAPI формирует новый `GET` запрос на `http://{instance_id}/statistics` и отправляет его в **Game Service**.
6.  **Game Service** обращается к своей базе данных или внутреннему состоянию, формирует отчет по статистике и возвращает его в виде JSON.
7.  **WebAPI Service** получает ответ от `Game Service` и полностью перенаправляет его (включая тело, заголовки и статус-код) обратно **клиенту**.
8.  **Клиент** получает данные и отображает их пользователю.
