# CNN Архитектура для Bomberman AI

## Обзор

Для обработки пространственных данных игрового поля (grid observations) используется кастомная CNN (сверточная нейронная сеть) архитектура `BombermanCNN`. Это позволяет модели эффективно извлекать пространственные паттерны из карты игры, что критично для принятия стратегических решений.

## Структура наблюдений

Наблюдения (observations) представлены в виде словаря с двумя ключами:

- **`grid`**: Пространственные данные карты игры
  - Форма: `(GRID_CHANNELS, WINDOW_SIZE, WINDOW_SIZE)` = `(5, 15, 15)`
  - 5 каналов:
    1. `terrain` - рельеф местности (стены, разрушаемые блоки, выходы)
    2. `player` - позиция игрока
    3. `enemies` - позиции врагов
    4. `weapons` - позиции бомб/оружия
    5. `powerups` - позиции бонусов

- **`stats`**: Векторные статистические данные
  - Форма: `(STATS_SIZE,)` = `(9,)`
  - Содержит нормализованные значения: lives, enemies, bombs, range, invulnerability, speed, time и др.

## Архитектура BombermanCNN

### Структура сети

CNN состоит из трех сверточных слоев с последующим полносвязным слоем:

```python
Conv2d(5 → 32, kernel=8x8, stride=4) → ReLU
Conv2d(32 → 64, kernel=4x4, stride=2) → ReLU  
Conv2d(64 → 64, kernel=3x3, stride=1) → ReLU
Flatten
Linear(n_flatten → features_dim) → ReLU
```

### Параметры слоев

1. **Первый сверточный слой**:
   - Вход: `(batch, 5, 15, 15)`
   - Выход: `(batch, 32, H', W')`
   - Большой kernel (8×8) с stride=4 для захвата широких пространственных паттернов
   - Уменьшает размерность карты признаков

2. **Второй сверточный слой**:
   - Вход: `(batch, 32, H', W')`
   - Выход: `(batch, 64, H'', W'')`
   - Средний kernel (4×4) с stride=2 для промежуточных признаков
   - Дальнейшее уменьшение размерности

3. **Третий сверточный слой**:
   - Вход: `(batch, 64, H'', W'')`
   - Выход: `(batch, 64, H''', W''')`
   - Малый kernel (3×3) с stride=1 для детальных признаков
   - Сохраняет пространственную информацию

4. **Полносвязный слой**:
   - Преобразует свернутые признаки в фиксированный вектор размерности `features_dim` (по умолчанию 512)

### Расчет параметров модели

Количество параметров в сверточном слое рассчитывается по формуле:

```
params = (kernel_h × kernel_w × in_channels + 1) × out_channels
```

**Пример для входа (5, 15, 15) и features_dim=512:**

- Conv1: `(8×8×5 + 1) × 32 ≈ 10,272 параметров`
- Conv2: `(4×4×32 + 1) × 64 ≈ 32,832 параметров`
- Conv3: `(3×3×64 + 1) × 64 ≈ 36,928 параметров`
- Linear: зависит от размера после flatten (автоматически вычисляется)

**Итого**: ~80K-100K параметров только для CNN части (без учета LSTM и MLP для stats)

## Использование в обучении

### Включение CNN

CNN feature extractor включается через параметр `use_cnn=True` в методе `start_training()`:

```python
training_service.start_training(
    total_timesteps=100000,
    log_name="bomberman_cnn",
    use_cnn=True,
    features_dim=512,
)
```

### Обработка наблюдений

`MultiInputLstmPolicy` автоматически определяет тип feature extractor для каждого ключа:

- **`grid`** (форма `(5, 15, 15)`): Используется `BombermanCNN` для пространственной обработки
- **`stats`** (форма `(9,)`): Используется стандартный MLP extractor для векторных данных

Результаты обработки объединяются перед передачей в LSTM слой.

## Адаптация к разным размерам окна

CNN автоматически адаптируется к изменению `WINDOW_SIZE`:

- При увеличении `WINDOW_SIZE` с 7 до 15:
  - Увеличивается количество параметров в сверточных слоях (пропорционально размеру feature maps)
  - Требуется больше памяти и вычислительных ресурсов
  - Может потребоваться больше данных для обучения
  - Размер выходных feature maps изменяется автоматически

**Важно**: При изменении `WINDOW_SIZE` необходимо синхронизировать значения во всех файлах:
- `app/ai_env/bomberman_env.py`
- `app/services/grpc_client.py`
- `app/services/grpc_server.py`
- `services/game-service/app/services/ai_observation.py`

## Рекомендации по настройке

### Когда использовать CNN

- ✅ **Используйте CNN**, если:
  - Grid наблюдения содержат важные пространственные паттерны
  - Модель не обучается хорошо с MLP
  - Нужно распознавать сложные пространственные структуры (лабиринты, группировки врагов)

- ❌ **Не используйте CNN**, если:
  - Очень ограниченные вычислительные ресурсы
  - Очень маленький размер окна (например, 3×3)
  - Пространственные паттерны не важны для задачи

### Настройка гиперпараметров

1. **`features_dim`**: Размерность выходных признаков CNN
   - Больше значение (512-1024): больше емкость модели, но больше параметров
   - Меньше значение (128-256): меньше параметров, быстрее обучение
   - Рекомендуется начинать с 512

2. **Архитектура CNN**: Можно изменить количество слоев и фильтров
   - Больше слоев: более сложные паттерны, но больше параметров
   - Больше фильтров: больше признаков, но больше параметров
   - Текущая архитектура (3 слоя, 32→64→64 фильтров) - хороший баланс

3. **Размер окна (`WINDOW_SIZE`)**:
   - Больше окно (15×15): больше контекста, но больше вычислений
   - Меньше окно (7×7): быстрее обучение, но меньше контекста
   - Рекомендуется начинать с 15×15 для лучшей производительности

## Сравнение с MLP

### Преимущества CNN

- ✅ Эффективная обработка пространственных данных
- ✅ Инвариантность к небольшим сдвигам
- ✅ Меньше параметров при больших входах (за счет разделяемых весов)
- ✅ Лучшее извлечение пространственных паттернов

### Преимущества MLP

- ✅ Проще и быстрее для малых входов
- ✅ Меньше вычислительных ресурсов
- ✅ Может быть достаточно для простых задач

## Мониторинг обучения

При обучении с CNN рекомендуется отслеживать в TensorBoard:

- `train/learning_rate` - скорость обучения
- `train/policy_loss` - потеря политики
- `train/value_loss` - потеря функции ценности
- `train/approx_kl` - приблизительная дивергенция KL
- `rollout/ep_rew_mean` - средняя награда за эпизод
- `time/fps` - скорость обучения (кадров в секунду)

CNN может замедлить обучение из-за дополнительных вычислений, но должно улучшить качество модели.

## Примеры использования

### Базовое обучение с CNN

```python
from app.training.trainer import TrainingService
from app.services.grpc_client import GameServiceGRPCClient

grpc_client = GameServiceGRPCClient(...)
training_service = TrainingService(grpc_client=grpc_client)

# Обучение с CNN
training_service.start_training(
    total_timesteps=100000,
    log_name="bomberman_cnn_v1",
    use_cnn=True,
    features_dim=512,
    enable_evaluation=True,
    eval_freq=5000,
)
```

### Обучение без CNN (MLP)

```python
# Обучение без CNN (используется стандартный MLP)
training_service.start_training(
    total_timesteps=100000,
    log_name="bomberman_mlp_v1",
    use_cnn=False,
    enable_evaluation=True,
    eval_freq=5000,
)
```

### Сравнение архитектур

Рекомендуется провести эксперименты с обеими архитектурами и сравнить результаты в TensorBoard для выбора оптимальной конфигурации.

